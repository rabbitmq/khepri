<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module khepri_path</title>
<link rel="stylesheet" type="text/css" href="edoc-extensions.css" title="EDoc">
<link rel="icon" href="khepri-favicon.svg" type="image/svg+xml">
</head>
<body class="markdown-body language-erlang"><script src="prism.js"></script>
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module khepri_path</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>Khepri path API.


<h2><a name="description">Description</a></h2><p>Khepri path API.</p>
 
  <p>A path is the type used by Khepri to reference nodes in the tree structure.  
A path describes how to reach a node from the root node.</p>
 
  <p>A path, or <em>native path</em>, is a list of components. Components can be  
Erlang atoms and binaries. Example:</p>
 
  <pre><code>%% Native path.
Path = [stock, wood, &lt;&lt;"oak"&gt;&gt;].</code></pre>
 
  <p>A path may contain conditions to tune how a node is matched or to match
  multiple nodes at once. This is called a <em>path pattern</em>. A path
  pattern may contain conditions in addition to regular components (Erlang
  atoms and binaries). See <a docgen-rel="seeerl" docgen-href="khepri_condition" href="khepri_condition.html"><code>khepri_condition</code></a> to learn more about  
conditions. Example:</p>
 
  <pre><code>%% Path pattern with a condition on `wood'.
PathPattern = [stock,
               #if_all{conditions = [wood,
                                     #if_node_exists{exists = true}]},
               oak].</code></pre>
 
  <p>To be user-friendly, string-based and binary-based <em>Unix-like paths</em>
  are accepted by most functions. The syntax of these <em>Unix paths</em> is
  described in the <a docgen-rel="seetype" docgen-href="#unix_path/0" href="#type-unix_path"><code>unix_path()</code></a> type documentation. Example:</p>
 
  <pre><code>%% Unix path, equivalent of the first native path example.
UnixPath = "/:stock/:wood/oak".</code></pre>
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-component">component()</a></h3>
<p><code>component() = <a href="#type-node_id">node_id()</a> | 47 | 46 | 94</code></p>
<p>  Component name in a path to a node.</p>

<h3 class="typedecl"><a name="type-native_path">native_path()</a></h3>
<p><code>native_path() = [<a href="#type-component">component()</a>]</code></p>
<p><p>  Native path to a node.</p>
 
  <p>A native path is a list of atoms, binaries and special components.</p>
 
  <p>It is called <em>native</em> because it requires no further processing
  (unlike <a docgen-rel="seetype" docgen-href="#unix_path/0" href="#type-unix_path"><code>unix_path()</code></a>) and is the format used internally by the state  
machine.</p>
 
  Special components are:
  <ol>
  <li><code>?ROOT_NODE</code> to explicitly mark the root node. A path is absolute by
  default. Using <code>?ROOT_NODE</code> is only useful when manipulating the root node
  itself (querying it or storing something in the root node).</li>
  <li><code>?THIS_NODE</code> to make a relative path (the default being an absolute
  path). This is mostly useful for <a docgen-rel="seetype" docgen-href="khepri_condition#keep_while/0" href="khepri_condition.html#type-keep_while"><code>khepri_condition:keep_while()</code></a> to
  make it easy to put a condition on the node itself.</li>
  <li><code>?PARENT_NODE</code> to target the parent of a node, with the same benefits
  and use cases as <code>?THIS_NODE</code>.</li>
  </ol>
 
  <p>Example:</p>
 
  <pre><code>%% Native path.
Path = [stock, wood, &lt;&lt;"oak"&gt;&gt;].</code></pre></p>

<h3 class="typedecl"><a name="type-native_pattern">native_pattern()</a></h3>
<p><code>native_pattern() = [<a href="#type-pattern_component">pattern_component()</a>]</code></p>
<p><p>  Path pattern which may match zero, one or more nodes.</p>
 
  <p>A native pattern is a list of atoms, binaries, special components and  
conditions.</p>
 
  <p>It is called <em>native</em> because it requires no further processing
  (unlike <a docgen-rel="seetype" docgen-href="#unix_pattern/0" href="#type-unix_pattern"><code>unix_pattern()</code></a>) and is the format used internally by the  
state machine.</p>
 
  <p>See <a docgen-rel="seetype" docgen-href="#native_path/0" href="#type-native_path"><code>native_path()</code></a> for a description of special components.</p>
 
  <p>Conditions are any condition defined by <a docgen-rel="seetype" docgen-href="khepri_condition#condition/0" href="khepri_condition.html#type-condition"><code>khepri_condition:condition()</code></a>.</p>
 
  <p>Example:</p>
 
  <pre><code>%% Path pattern with a condition on `wood'.
PathPattern = [stock,
               #if_all{conditions = [wood,
                                     #if_node_exists{exists = true}]},
               oak].</code></pre></p>

<h3 class="typedecl"><a name="type-node_id">node_id()</a></h3>
<p><code>node_id() = atom() | binary()</code></p>
<p>  A node name.</p>

<h3 class="typedecl"><a name="type-path">path()</a></h3>
<p><code>path() = <a href="#type-native_path">native_path()</a> | <a href="#type-unix_path">unix_path()</a></code></p>
<p>  Path to a node.</p>

<h3 class="typedecl"><a name="type-pattern">pattern()</a></h3>
<p><code>pattern() = <a href="#type-native_pattern">native_pattern()</a> | <a href="#type-unix_pattern">unix_pattern()</a></code></p>
<p>  Path pattern which may match zero, one or more nodes.</p>

<h3 class="typedecl"><a name="type-pattern_component">pattern_component()</a></h3>
<p><code>pattern_component() = <a href="#type-component">component()</a> | <a href="/home/runner/work/khepri/khepri/doc/khepri_condition.html#type-condition">khepri_condition:condition()</a></code></p>
<p>  Path pattern component which may match zero, one or more nodes.</p>

<h3 class="typedecl"><a name="type-unix_path">unix_path()</a></h3>
<p><code>unix_path() = string() | binary()</code></p>
<p><p>  Unix-like path to a node.</p>
 
  <p>These <em>Unix paths</em> have the following syntax:</p>
 
  <ul>
  <li>Path components are separated by a forward slash, <code>/</code>.</li>
  <li>Atom-based node IDs are prefixed with a <code>:</code> character: <code>:wood</code>.</li>
  <li>Binary-based node IDs are written as-is: <code>oak</code>.</li>
  <li>Atom and binaries can be percent-encoded.</li>
  <li>An absolute path must start with <code>/</code>, otherwise it is considered a
  relative path</li>
  <li><code>.</code> and <code>..</code> represent <code>?THIS_NODE</code> and <code>?PARENT_NODE</code>
  respectively</li>
  <li>Simple glob patterns are accepted:
  <ul>
  <li><code>abc*def</code> is the same as <code>#if_name_matches{regex = "^abc.*def$"}</code></li>
  <li><code>*</code> is the same as <code>?STAR</code> or <code>#if_name_matches{regex = any}</code></li>
  <li><code>**</code> is the same as <code>?STAR_STAR</code> or <code>if_path_matches{regex = any}</code></li>
  </ul></li>
  </ul>
 
  <p><strong>Warning</strong>: There is no special handling of Unicode in tree  
node names. To use Unicode, it is recommended to either use a native path or  
a binary-based Unix-like path. If using a string-based Unix-like path, the  
behavior is undefined and the call may crash. Matching against node names is  
also undefined behavior and may crash, regardless of the type of path being  
used. It will be improved in the future.</p>
 
  Example:
  <pre><code>%% Unix path, equivalent of the first native path example.
UnixPath = "/:stock/:wood/oak".</code></pre></p>

<h3 class="typedecl"><a name="type-unix_pattern">unix_pattern()</a></h3>
<p><code>unix_pattern() = string() | binary()</code></p>
<p><p>  Unix-like path pattern to a node.</p>
 
  It accepts the following special characters:
  <ol>
  <li><code>*</code> anywhere in a path component behaves like a <a docgen-rel="seetype" docgen-href="khepri_condition#if_name_matches/0" href="khepri_condition.html#type-if_name_matches"><code>khepri_condition:if_name_matches()</code></a>.</li>
  <li><code>**</code> as a path component behaves like a <a docgen-rel="seetype" docgen-href="khepri_condition#if_path_matches/0" href="khepri_condition.html#type-if_path_matches"><code>khepri_condition:if_path_matches()</code></a>.</li>
  </ol>
 
  <p>A Unix-like path pattern can't express all the conditions of a native path  
pattern currently.</p>
 
  <p>Otherwise it works as a <a docgen-rel="seetype" docgen-href="#unix_path/0" href="#type-unix_path"><code>unix_path()</code></a> and has the same syntax and  
limitations.</p>
 
  Example:
  <pre><code>%% Unix path pattern, matching multiple types of oak.
UnixPathPattern = "/:stock/:wood/*oak".</code></pre></p>

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#from_string-1">from_string/1</a></td><td>Converts a Unix-like path to a native path.</td></tr>
<tr><td valign="top"><a href="#from_binary-1">from_binary/1</a></td><td>Converts a Unix-like path to a native path.</td></tr>
<tr><td valign="top"><a href="#to_string-1">to_string/1</a></td><td>Converts a native path to a string.</td></tr>
<tr><td valign="top"><a href="#to_binary-1">to_binary/1</a></td><td>Converts a native path to a binary.</td></tr>
<tr><td valign="top"><a href="#combine_with_conditions-2">combine_with_conditions/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#targets_specific_node-1">targets_specific_node/1</a></td><td></td></tr>
<tr><td valign="top"><a href="#is_valid-1">is_valid/1</a></td><td></td></tr>
<tr><td valign="top"><a href="#ensure_is_valid-1">ensure_is_valid/1</a></td><td></td></tr>
<tr><td valign="top"><a href="#abspath-2">abspath/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#realpath-1">realpath/1</a></td><td></td></tr>
<tr><td valign="top"><a href="#pattern_includes_root_node-1">pattern_includes_root_node/1</a></td><td></td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="from_string-1">from_string/1</a></h3>
<div class="spec">
<p><code>from_string(String) -&gt; PathPattern</code>
<ul class="definitions"><li><code>String = <a href="#type-pattern">pattern()</a></code></li><li><code>PathPattern = <a href="#type-native_pattern">native_pattern()</a></code></li></ul></p>
<p></p>
</div><p><p>Converts a Unix-like path to a native path.</p>
 
  <p>The Unix-like string can be either an Erlang string or an Erlang binary.</p>
 
  For convenience, a native path is also accepted and returned as-is.</p>

<h3 class="function"><a name="from_binary-1">from_binary/1</a></h3>
<div class="spec">
<p><code>from_binary(String) -&gt; PathPattern</code>
<ul class="definitions"><li><code>String = <a href="#type-pattern">pattern()</a></code></li><li><code>PathPattern = <a href="#type-native_pattern">native_pattern()</a></code></li></ul></p>
<p></p>
</div><p><p>Converts a Unix-like path to a native path.</p>
 
  This is the same as calling <code>from_string(String)</code>. Therefore, it accepts
  Erlang strings or binaries and native paths.
 </p>
<p><b>See also:</b> <a href="#from_string-1">from_string/1</a>.</p>

<h3 class="function"><a name="to_string-1">to_string/1</a></h3>
<div class="spec">
<p><code>to_string(NativePath) -&gt; UnixPath</code>
<ul class="definitions"><li><code>NativePath = <a href="#type-native_path">native_path()</a></code></li><li><code>UnixPath = string()</code></li></ul></p>
<p></p>
</div><p>Converts a native path to a string.</p>

<h3 class="function"><a name="to_binary-1">to_binary/1</a></h3>
<div class="spec">
<p><code>to_binary(NativePath) -&gt; UnixPath</code>
<ul class="definitions"><li><code>NativePath = <a href="#type-native_path">native_path()</a></code></li><li><code>UnixPath = binary()</code></li></ul></p>
<p></p>
</div><p>Converts a native path to a binary.</p>

<h3 class="function"><a name="combine_with_conditions-2">combine_with_conditions/2</a></h3>
<div class="spec">
<p><code>combine_with_conditions(PathPattern, Conditions) -&gt; PathPattern</code>
<ul class="definitions"><li><code>PathPattern = <a href="#type-native_pattern">native_pattern()</a></code></li><li><code>Conditions = [<a href="/home/runner/work/khepri/khepri/doc/khepri_condition.html#type-condition">khepri_condition:condition()</a>]</code></li></ul></p>
<p></p>
</div>

<h3 class="function"><a name="targets_specific_node-1">targets_specific_node/1</a></h3>
<div class="spec">
<p><code>targets_specific_node(PathPattern) -&gt; Ret</code>
<ul class="definitions"><li><code>PathPattern = <a href="#type-native_pattern">native_pattern()</a></code></li><li><code>Ret = {true, Path} | false</code></li><li><code>Path = <a href="#type-native_path">native_path()</a></code></li></ul></p>
<p></p>
</div>

<h3 class="function"><a name="is_valid-1">is_valid/1</a></h3>
<div class="spec">
<p><code>is_valid(PathPattern) -&gt; IsValid</code>
<ul class="definitions"><li><code>PathPattern = <a href="#type-native_pattern">native_pattern()</a></code></li><li><code>IsValid = true | {false, ComponentPattern}</code></li><li><code>ComponentPattern = <a href="#type-pattern_component">pattern_component()</a></code></li></ul></p>
<p></p>
</div>

<h3 class="function"><a name="ensure_is_valid-1">ensure_is_valid/1</a></h3>
<div class="spec">
<p><code>ensure_is_valid(PathPattern) -&gt; ok | no_return()</code>
<ul class="definitions"><li><code>PathPattern = <a href="#type-native_pattern">native_pattern()</a></code></li></ul></p>
<p></p>
</div>

<h3 class="function"><a name="abspath-2">abspath/2</a></h3>
<div class="spec">
<p><code>abspath(Path, BasePath) -&gt; Path</code>
<ul class="definitions"><li><code>Path = <a href="#type-native_pattern">native_pattern()</a></code></li><li><code>BasePath = <a href="#type-native_pattern">native_pattern()</a></code></li></ul></p>
<p></p>
</div>

<h3 class="function"><a name="realpath-1">realpath/1</a></h3>
<div class="spec">
<p><code>realpath(Path) -&gt; Path</code>
<ul class="definitions"><li><code>Path = <a href="#type-native_pattern">native_pattern()</a></code></li></ul></p>
<p></p>
</div>

<h3 class="function"><a name="pattern_includes_root_node-1">pattern_includes_root_node/1</a></h3>
<div class="spec">
<p><code>pattern_includes_root_node(Path) -&gt; any()</code></p>
<p></p>
</div>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
