<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module khepri_fun</title>
<link rel="stylesheet" type="text/css" href="github-markdown.css" title="EDoc">
<link href="prism.css" rel="stylesheet" /><style>
    body {
      box-sizing: border-box;
      min-width: 200px;
      max-width: 980px;
      margin: 0 auto;
      padding: 45px;
    }
    @media (max-width: 767px) {
      body {
        padding: 15px;
      }
    }
    /* Don't apply the table style to the top-level navigation bar. */
    .navbar table {
      display: table;
      width: 100%;
    }
    .navbar table tr,
    .navbar table th,
    .navbar table td {
      border: 0;
    }
    /* Keep the same font side inside code blocks than everywhere else. */
    .markdown-body pre code,
    code[class*="language-"] {
      font-size: 85%;
    }
    /* Force the color for link on code blocks used for @see tags.  */
    .markdown-body a code,
    .markdown-body a code span.token {
      color: var(--color-accent-fg);
    }
    /* Copy the style of code blocks. */
    .markdown-body .spec {
      background: #f5f2f0;
      padding: 1em;
      margin: .5em 0;
      overflow: auto;
      border-radius: 6px;
    }
    /* Improve margins inside function spec blocks so that:
        - empty paragraphs don't add useless margins
        - the final top and bottom margins are equal */
    .markdown-body .spec p,
    .markdown-body .spec ul {
      margin-top: 16px;
      margin-bottom: 0;
    }
    .markdown-body .spec p:first-child,
    .markdown-body .spec p:empty {
      margin-top: 0;
    }
    /* Put the function prototype in bold characters. */
    .markdown-body .spec > p > code:first-child {
      font-weight: bold;
    }
    /* Add some margin below the module short description between the table
       of contents in the Description section. This text isn't in a
       <p></p>. */
    .index + p {
      margin-top: 16px;
    }
    </style></head>
<body class="markdown-body language-erlang"><script src="prism.js"></script>
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module khepri_fun</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>Anonymous function extraction private API.


<h2><a name="description">Description</a></h2><p>Anonymous function extraction private API.</p>
 
  <p>This module is responsible for extracting the code of an anonymous function.  
The goal is to be able to store the extracted function and execute it later,  
regardless of the availability of the initial Erlang module which declared  
it.</p>
 
  <p>This module also provides a way for the caller to indicate forbidden  
operations or function calls.</p>
 
  <p>This module works on assembly code to perform all checks and prepare the
  storable copy of a function. It uses <a docgen-rel="seemfa" docgen-href="beam_disasm#file/1" href="beam_disasm.html#file-1"><code>beam_disasm:file/1</code></a> from the
  <code>compiler</code> application to extract the assembly code. After the assembly  
code was extracted and modified, the compiler is used again to compile the  
code back to an executable module.</p>
 
  <p>If the anonymous function calls other functions, either in the same module  
or in another one, the code of the called functions is extracted and copied  
as well. This is to make sure the result is completely standalone.</p>
 
  <p>To avoid any copies of standard Erlang APIs or Khepri itself, it is  
possible to specify a list of modules which should not be copied. In this  
case, calls to functions in those modules are left unmodified.</p>
 
  <p>Once the code was extracted and verified, a new module is generated as an
  "assembly form", ready to be compiled again to an executable module. The
  generated module has a single <code>run/N</code> function. This function contains the  
code of the extracted anonymous function.</p>
 
  <p>Because this process works on the assembly code, it means that if the  
initial module hosting the anonymous function was compiled with Erlang  
version N, it will probably not compile or run on older versions of Erlang.  
The reason is that a newer compiler may use instructions which are unknown  
to older runtimes.</p>
 
  <p>There is a special treatment for anonymous functions evaluated by
  <code>erl_eval</code> (e.g. in the Erlang shell). "erl_eval functions" are lambdas
  parsed from text and are evaluated using <code>erl_eval</code>.</p>
 
  <p>This kind of lambdas becomes a local function in the <code>erl_eval</code> module.</p>
 
  <p>Their assembly code isn't available in the <code>erl_eval</code> module. However, the
  abstract code (i.e. after parsing but before compilation) is available in
  the <code>env</code>. We compile that abstract code and extract the assembly from that  
compiled beam.</p>
 
  This module is private. The documentation is still visible because it may
  help understand some implementation details. However, this module should
  never be called directly outside of Khepri.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-beam_instr">beam_instr()</a></h3>
<p><code>beam_instr() = atom() | tuple()</code></p>


<h3 class="typedecl"><a name="type-ensure_instruction_is_permitted_fun">ensure_instruction_is_permitted_fun()</a></h3>
<p><code>ensure_instruction_is_permitted_fun() = fun((Instruction::<a href="#type-beam_instr">beam_instr()</a>) -&gt; ok)</code></p>
<p><p>  Function which evaluates the given instruction and returns <code>ok</code> if it is  
permitted, throws an exception otherwise.</p>
 
  <p>Example:</p>
 
  <pre><code>Fun = fun
          ({jump, _})    -&gt; ok;
          ({move, _, _}) -&gt; ok;
          ({trim, _, _}) -&gt; ok;
          (Unknown)      -&gt; throw({unknown_instruction, Unknown})
      end.</code></pre></p>

<h3 class="typedecl"><a name="type-is_standalone_fun_still_needed_fun">is_standalone_fun_still_needed_fun()</a></h3>
<p><code>is_standalone_fun_still_needed_fun() = fun((#{calls := #{Call::mfa() =&gt; true}, errors := [Error::any()]}) -&gt; IsNeeded::boolean())</code></p>
<p><p>  Function which evaluates if the extracted function is still relevant in the  
end. It returns true if it is, false otherwise.</p>
 
  It takes a map with the following members:
  <ul>
  <li><code>calls</code>, a map of all the calls performed by the extracted code (only
  the key is useful, the value is always true).</li>
  <li><code>errors</code>, a list of errors collected during the extraction.</li>
  </ul></p>

<h3 class="typedecl"><a name="type-options">options()</a></h3>
<p><code>options() = #{ensure_instruction_is_permitted =&gt; <a href="#type-ensure_instruction_is_permitted_fun">ensure_instruction_is_permitted_fun()</a>, should_process_function =&gt; <a href="#type-should_process_function_fun">should_process_function_fun()</a>, is_standalone_fun_still_needed =&gt; <a href="#type-is_standalone_fun_still_needed_fun">is_standalone_fun_still_needed_fun()</a>}</code></p>
<p><p>  Options to tune the extraction of an anonymous function.</p>
 
  <ul>
  <li><code>ensure_instruction_is_permitted</code>: a function which evaluates if an
  instruction is permitted or not.</li>
  <li><code>should_process_function</code>: a function which returns if a called module
  and function should be extracted as well or left alone.</li>
  <li><code>is_standalone_fun_still_needed</code>: a function which returns if, after
  the extraction is finished, the extracted function is still needed in
  comparison to keeping the initial anonymous function.</li>
  </ul></p>

<h3 class="typedecl"><a name="type-should_process_function_fun">should_process_function_fun()</a></h3>
<p><code>should_process_function_fun() = fun((Module::module(), Function::atom(), Arity::arity(), FromModule::module()) -&gt; ShouldProcess::boolean())</code></p>
<p><p>  Function which returns true if a called function should be extracted and  
followed, false otherwise.</p>
 
  <p><code>Module</code>, <code>Function</code> and <code>Arity</code> qualify the function being called.</p>
 
  <p><code>FromModule</code> indicates the module performing the call. This is useful to
  distinguish local calls (<code>FromModule</code> == <code>Module</code>) from remote calls.</p>
 
  <p>Example:</p>
 
  <pre><code>Fun = fun(Module, Name, Arity, FromModule) -&gt;
              Module =:= FromModule orelse
              erlang:function_exported(Module, Name, Arity)
      end.</code></pre></p>

<h3 class="typedecl"><a name="type-standalone_fun">standalone_fun()</a></h3>
<p><code>standalone_fun() = #standalone_fun{module = module(), beam = binary(), arity = arity(), literal_funs = [<a href="/home/runner/work/khepri/khepri/doc/khepri_fun.html#type-standalone_fun">khepri_fun:standalone_fun()</a>], env = list()} | function()</code></p>
<p><p>  The result of an extraction, as returned by <a docgen-rel="seemfa" docgen-href="#to_standalone_fun/2" href="#to_standalone_fun-2"><code>to_standalone_fun/2</code></a>.</p>
 
  It can be stored, passed between processes and Erlang nodes. To execute the
  extracted function, simply call <a docgen-rel="seemfa" docgen-href="#exec/2" href="#exec-2"><code>exec/2</code></a> which works like <a docgen-rel="seemfa" docgen-href="erlang#apply/2" href="erlang.html#apply-2"><code>erlang:apply/2</code></a>.</p>

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#to_standalone_fun-1">to_standalone_fun/1</a></td><td>Extracts the given anonymous function.</td></tr>
<tr><td valign="top"><a href="#to_standalone_fun-2">to_standalone_fun/2</a></td><td>Extracts the given anonymous function.</td></tr>
<tr><td valign="top"><a href="#exec-2">exec/2</a></td><td>Executes a previously extracted anonymous function.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="to_standalone_fun-1">to_standalone_fun/1</a></h3>
<div class="spec">
<p><code>to_standalone_fun(Fun) -&gt; StandaloneFun</code>
<ul class="definitions"><li><code>Fun = function()</code></li><li><code>StandaloneFun = <a href="#type-standalone_fun">standalone_fun()</a></code></li></ul></p>
<p><code>Fun</code>: the anonymous function to extract
 <br>
</p>
<p>returns: a standalone function record or the same anonymous function if no
  extraction was needed.</p>
</div><p><p>Extracts the given anonymous function</p>
 
  This is the same as:
  <pre><code>khepri_fun:to_standalone_fun(Fun, #{}).</code></pre>
 </p>

<h3 class="function"><a name="to_standalone_fun-2">to_standalone_fun/2</a></h3>
<div class="spec">
<p><code>to_standalone_fun(Fun, Options) -&gt; StandaloneFun</code>
<ul class="definitions"><li><code>Fun = function()</code></li><li><code>Options = <a href="#type-options">options()</a></code></li><li><code>StandaloneFun = <a href="#type-standalone_fun">standalone_fun()</a></code></li></ul></p>
<p><code>Fun</code>: the anonymous function to extract<br>
<code>Options</code>: a map of options
 <br>
</p>
<p>returns: a standalone function record or the same anonymous function if no
  extraction was needed.</p>
</div><p>Extracts the given anonymous function
 </p>

<h3 class="function"><a name="exec-2">exec/2</a></h3>
<div class="spec">
<p><code>exec(StandaloneFun, Args) -&gt; Ret</code>
<ul class="definitions"><li><code>StandaloneFun = <a href="#type-standalone_fun">standalone_fun()</a></code></li><li><code>Args = [any()]</code></li><li><code>Ret = any()</code></li></ul></p>
<p><code>StandaloneFun</code>: the extracted function as returned by <a docgen-rel="seemfa" docgen-href="#to_standalone_fun/2" href="#to_standalone_fun-2"><code>to_standalone_fun/2</code></a>.<br>
<code>Args</code>: the list of arguments to pass to the extracted function.
 <br>
</p>
<p>returns: the return value of the extracted function.</p>
</div><p><p>Executes a previously extracted anonymous function.</p>
 
  <p>This is the equivalent of <a docgen-rel="seemfa" docgen-href="erlang#apply/2" href="erlang.html#apply-2"><code>erlang:apply/2</code></a> but it supports extracted  
anonymous functions.</p>
 
  The list of <code>Args</code> must match the arity of the anonymous function.
 </p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
