<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module khepri_fun</title>
<link rel="stylesheet" type="text/css" href="github-markdown.css" title="EDoc">
<link href="prism.css" rel="stylesheet" /><style>
    body {
      box-sizing: border-box;
      min-width: 200px;
      max-width: 980px;
      margin: 0 auto;
      padding: 45px;
    }

    @media (max-width: 767px) {
      body {
        padding: 15px;
      }
    }

    /* Don't apply the table style to the top-level navigation bar. */
    .navbar table {
      display: table;
      width: 100%;
    }
    .navbar table tr,
    .navbar table th,
    .navbar table td {
      border: 0;
    }

    /* Keep the same font side inside code blocks than everywhere else. */
    .markdown-body pre code,
    code[class*="language-"] {
      font-size: 85%;
    }

    /* Force the color for link on code blocks used for @see tags.  */
    .markdown-body a code,
    .markdown-body a code span.token {
      color: var(--color-accent-fg);
    }

    /* Copy the style of code blocks. */
    .markdown-body .spec {
      background: #f5f2f0;
      padding: 1em;
      margin: .5em 0;
      overflow: auto;
      border-radius: 6px;
    }

    /* Improve margins inside function spec blocks so that:
        - empty paragraphs don't add useless margins
        - the final top and bottom margins are equal */
    .markdown-body .spec p,
    .markdown-body .spec ul {
      margin-top: 16px;
      margin-bottom: 0;
    }
    .markdown-body .spec p:first-child,
    .markdown-body .spec p:empty {
      margin-top: 0;
    }

    /* Put the function prototype in bold characters. */
    .markdown-body .spec > p > code:first-child {
      font-weight: bold;
    }

    /* Add some margin below the module short description between the table
       of contents in the Description section. This text isn't in a
       <p></p>. */
    .index + p {
      margin-top: 16px;
    }
    </style></head>
<body class="markdown-body language-erlang"><script src="prism.js"></script>
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module khepri_fun</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>Anonymous function extraction API.


<h2><a name="description">Description</a></h2><p>Anonymous function extraction API.</p>
 
  <p>This module is responsible for extracting the code of an anonymous  
function. The goal is to be able to store the extracted function and  
execute it later, regardless of the available of the initial Erlang module  
which declared it.</p>
 
  <p>This module also provides a way for the caller to indicate forbidden  
operations or function calls.</p>
 
  <p>This module works on assembly code to perform all checks and prepare the
  storable copy of a function. It uses <a docgen-rel="seemfa" docgen-href="beam_disasm#file/1" href="beam_disasm.html#file-1"><code>beam_disasm:file/1</code></a> from the
  <code>compiler</code> application to extract the assembly code. After the assembly  
code was extracted and modified, the compiler is used again to compile the  
code back to an executable module.</p>
 
  <p>If the anonymous function calls other functions, either in the same module  
or in another one, the code of the called functions is extracted and copied  
as well. This is to make sure the result is completely standalone.</p>
 
  <p>To avoid any copies of standard Erlang APIs or Khepri itself, it is  
possible to specify a list of modules which should not be copied. In this  
case, calls to functions in those modules are left unmodified.</p>
 
  <p>Once the code was extracted and verified, a new module is generated as an
  "assembly form", ready to be compiled again to an executable module. The
  generated module has a single <code>run/N</code> function. This function contains the  
code of the extracted anonymous function.</p>
 
  <p>Because this process works on the assembly code, it means that if the  
initial module hosting the anonymous function was compiled with Erlang  
version N, it will probably not compile or run on older versions of Erlang.  
The reason is that a newer compiler may use instructions which are unknown  
to older runtimes.</p>
 
  <p>There is a special treatment for anonymous functions evaluated by
  <code>erl_eval</code> (e.g. in the Erlang shell). "erl_eval functions" are lambdas
  parsed from text and are evaluated using <code>erl_eval</code>.</p>
 
  <p>This kind of lambdas becomes a local function in the <code>erl_eval</code> module.</p>
 
  Their assembly code isn't available in the <code>erl_eval</code> module. However, the
  abstract code (i.e. after parsing but before compilation) is available in
  the <code>env</code>. We compile that abstract code and extract the assembly from that
  compiled beam.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-beam_instr">beam_instr()</a></h3>
<p><code>beam_instr() = atom() | tuple()</code></p>


<h3 class="typedecl"><a name="type-ensure_instruction_is_permitted_fun">ensure_instruction_is_permitted_fun()</a></h3>
<p><code>ensure_instruction_is_permitted_fun() = fun((<a href="#type-beam_instr">beam_instr()</a>) -&gt; ok)</code></p>


<h3 class="typedecl"><a name="type-options">options()</a></h3>
<p><code>options() = #{ensure_instruction_is_permitted =&gt; <a href="#type-ensure_instruction_is_permitted_fun">ensure_instruction_is_permitted_fun()</a>, should_process_function =&gt; <a href="#type-should_process_function_fun">should_process_function_fun()</a>}</code></p>


<h3 class="typedecl"><a name="type-should_process_function_fun">should_process_function_fun()</a></h3>
<p><code>should_process_function_fun() = fun((module(), atom(), arity(), module()) -&gt; boolean())</code></p>


<h3 class="typedecl"><a name="type-standalone_fun">standalone_fun()</a></h3>
<p><code>standalone_fun() = #standalone_fun{module = module(), beam = binary(), arity = arity(), env = list()} | function()</code></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#to_standalone_fun-2">to_standalone_fun/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#exec-2">exec/2</a></td><td></td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="to_standalone_fun-2">to_standalone_fun/2</a></h3>
<div class="spec">
<p><code>to_standalone_fun(Fun, Options) -&gt; StandaloneFun</code>
<ul class="definitions"><li><code>Fun = function()</code></li><li><code>Options = <a href="#type-options">options()</a></code></li><li><code>StandaloneFun = <a href="#type-standalone_fun">standalone_fun()</a></code></li></ul></p>
<p></p>
</div>

<h3 class="function"><a name="exec-2">exec/2</a></h3>
<div class="spec">
<p><code>exec(StandaloneFun, Args) -&gt; Ret</code>
<ul class="definitions"><li><code>StandaloneFun = <a href="#type-standalone_fun">standalone_fun()</a></code></li><li><code>Args = [any()]</code></li><li><code>Ret = any()</code></li></ul></p>
<p></p>
</div>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
